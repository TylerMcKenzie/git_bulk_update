<?php
/**
 * Generated by Haxe 3.4.7
 */

namespace haxe\io;

use \php\Boot;
use \php\_Boot\HxString;

/**
 * This class provides a convenient way of working with paths. It supports the
 * common path formats:
 * - directory1/directory2/filename.extension
 * - directory1\directory2\filename.extension
 */
class Path {
	/**
	 * @var bool
	 * True if the last directory separator is a backslash, false otherwise.
	 */
	public $backslash;
	/**
	 * @var string
	 * The directory.
	 * This is the leading part of the path that is not part of the file name
	 * and the extension.
	 * Does not end with a `/` or `\` separator.
	 * If the path has no directory, the value is null.
	 */
	public $dir;
	/**
	 * @var string
	 * The file extension.
	 * It is separated from the file name by a dot. This dot is not part of
	 * the extension.
	 * If the path has no extension, the value is null.
	 */
	public $ext;
	/**
	 * @var string
	 * The file name.
	 * This is the part of the part between the directory and the extension.
	 * If there is no file name, e.g. for ".htaccess" or "/dir/", the value
	 * is the empty String "".
	 */
	public $file;


	/**
	 * Adds a trailing slash to `path`, if it does not have one already.
	 * If the last slash in `path` is a backslash, a backslash is appended to
	 * `path`.
	 * If the last slash in `path` is a slash, or if no slash is found, a slash
	 * is appended to `path`. In particular, this applies to the empty String
	 * `""`.
	 * If `path` is null, the result is unspecified.
	 * 
	 * @param string $path
	 * 
	 * @return string
	 */
	static public function addTrailingSlash ($path) {
		#/usr/share/haxe/std/haxe/io/Path.hx:263: lines 263-264
		if (strlen($path) === 0) {
			#/usr/share/haxe/std/haxe/io/Path.hx:264: characters 3-13
			return "/";
		}
		#/usr/share/haxe/std/haxe/io/Path.hx:265: characters 2-33
		$c1 = HxString::lastIndexOf($path, "/");
		#/usr/share/haxe/std/haxe/io/Path.hx:266: characters 2-34
		$c2 = HxString::lastIndexOf($path, "\\");
		#/usr/share/haxe/std/haxe/io/Path.hx:267: lines 267-273
		if ($c1 < $c2) {
			#/usr/share/haxe/std/haxe/io/Path.hx:268: lines 268-269
			if ($c2 !== (strlen($path) - 1)) {
				#/usr/share/haxe/std/haxe/io/Path.hx:268: characters 30-41
				return ($path??'null') . "\\";
			} else {
				#/usr/share/haxe/std/haxe/io/Path.hx:269: characters 8-12
				return $path;
			}
		} else if ($c1 !== (strlen($path) - 1)) {
			#/usr/share/haxe/std/haxe/io/Path.hx:271: characters 30-40
			return ($path??'null') . "/";
		} else {
			#/usr/share/haxe/std/haxe/io/Path.hx:272: characters 8-12
			return $path;
		}
	}


	/**
	 * Returns the extension of `path`.
	 * If the extension is null, the empty String `""` is returned.
	 * If `path` is null, the result is unspecified.
	 * 
	 * @param string $path
	 * 
	 * @return string
	 */
	static public function extension ($path) {
		#/usr/share/haxe/std/haxe/io/Path.hx:162: characters 2-25
		$s = new Path($path);
		#/usr/share/haxe/std/haxe/io/Path.hx:163: lines 163-164
		if ($s->ext === null) {
			#/usr/share/haxe/std/haxe/io/Path.hx:164: characters 3-12
			return "";
		}
		#/usr/share/haxe/std/haxe/io/Path.hx:165: characters 2-14
		return $s->ext;
	}


	/**
	 * Joins all paths in `paths` together.
	 * If `paths` is empty, the empty String `""` is returned. Otherwise the
	 * paths are joined with a slash between them.
	 * If `paths` is null, the result is unspecified.
	 * 
	 * @param \Array_hx $paths
	 * 
	 * @return string
	 */
	static public function join ($paths) {
		#/usr/share/haxe/std/haxe/io/Path.hx:190: characters 2-68
		$paths1 = $paths->filter(function ($s) {
			#/usr/share/haxe/std/haxe/io/Path.hx:190: characters 46-66
			if ($s !== null) {
				#/usr/share/haxe/std/haxe/io/Path.hx:190: characters 59-66
				return $s !== "";
			} else {
				#/usr/share/haxe/std/haxe/io/Path.hx:190: characters 46-66
				return false;
			}
		});
		#/usr/share/haxe/std/haxe/io/Path.hx:191: lines 191-193
		if ($paths1->length === 0) {
			#/usr/share/haxe/std/haxe/io/Path.hx:192: characters 3-12
			return "";
		}
		#/usr/share/haxe/std/haxe/io/Path.hx:194: characters 2-22
		$path = ($paths1->arr[0] ?? null);
		#/usr/share/haxe/std/haxe/io/Path.hx:195: lines 195-198
		$_g1 = 1;
		#/usr/share/haxe/std/haxe/io/Path.hx:195: lines 195-198
		$_g = $paths1->length;
		#/usr/share/haxe/std/haxe/io/Path.hx:195: lines 195-198
		while ($_g1 < $_g) {
			#/usr/share/haxe/std/haxe/io/Path.hx:195: lines 195-198
			$_g1 = $_g1 + 1;
			#/usr/share/haxe/std/haxe/io/Path.hx:195: characters 7-8
			$i = $_g1 - 1;
			#/usr/share/haxe/std/haxe/io/Path.hx:196: characters 3-32
			$path = Path::addTrailingSlash($path);
			#/usr/share/haxe/std/haxe/io/Path.hx:197: characters 3-19
			$path = ($path??'null') . (($paths1->arr[$i] ?? null)??'null');
		}

		#/usr/share/haxe/std/haxe/io/Path.hx:199: characters 2-24
		return Path::normalize($path);
	}


	/**
	 * Normalize a given `path` (e.g. make '/usr/local/../lib' to '/usr/lib').
	 * Also replaces backslashes \ with slashes / and afterwards turns
	 * multiple slashes into a single one.
	 * If `path` is null, the result is unspecified.
	 * 
	 * @param string $path
	 * 
	 * @return string
	 */
	static public function normalize ($path) {
		#/usr/share/haxe/std/haxe/io/Path.hx:211: characters 2-18
		$slash = "/";
		#/usr/share/haxe/std/haxe/io/Path.hx:212: characters 2-37
		$path = HxString::split($path, "\\")->join($slash);
		#/usr/share/haxe/std/haxe/io/Path.hx:213: characters 2-33
		if ($path === $slash) {
			#/usr/share/haxe/std/haxe/io/Path.hx:213: characters 21-33
			return $slash;
		}
		#/usr/share/haxe/std/haxe/io/Path.hx:215: characters 2-18
		$target = new \Array_hx();
		#/usr/share/haxe/std/haxe/io/Path.hx:217: lines 217-223
		$_g = 0;
		#/usr/share/haxe/std/haxe/io/Path.hx:217: lines 217-223
		$_g1 = HxString::split($path, $slash);
		#/usr/share/haxe/std/haxe/io/Path.hx:217: lines 217-223
		while ($_g < $_g1->length) {
			#/usr/share/haxe/std/haxe/io/Path.hx:217: characters 7-12
			$token = ($_g1->arr[$_g] ?? null);
			#/usr/share/haxe/std/haxe/io/Path.hx:217: lines 217-223
			$_g = $_g + 1;
			#/usr/share/haxe/std/haxe/io/Path.hx:218: lines 218-222
			if (($token === "..") && ($target->length > 0) && (($target->arr[$target->length - 1] ?? null) !== "..")) {
				#/usr/share/haxe/std/haxe/io/Path.hx:219: characters 4-16
				if ($target->length > 0) {
					#/usr/share/haxe/std/haxe/io/Path.hx:219: characters 4-16
					$target->length--;
				}
				#/usr/share/haxe/std/haxe/io/Path.hx:219: characters 4-16
				array_pop($target->arr);
			} else if ($token !== ".") {
				#/usr/share/haxe/std/haxe/io/Path.hx:221: characters 4-22
				$target->arr[$target->length] = $token;
				#/usr/share/haxe/std/haxe/io/Path.hx:221: characters 4-22
				++$target->length;
			}
		}

		#/usr/share/haxe/std/haxe/io/Path.hx:225: characters 2-31
		$tmp = $target->join($slash);
		#/usr/share/haxe/std/haxe/io/Path.hx:226: characters 2-28
		$regex = new \EReg("([^:])/+", "g");
		#/usr/share/haxe/std/haxe/io/Path.hx:227: characters 2-47
		$result = $regex->replace($tmp, "\$1" . ($slash??'null'));
		#/usr/share/haxe/std/haxe/io/Path.hx:228: characters 2-28
		$acc = new \StringBuf();
		#/usr/share/haxe/std/haxe/io/Path.hx:229: characters 2-20
		$colon = false;
		#/usr/share/haxe/std/haxe/io/Path.hx:230: characters 2-22
		$slashes = false;
		#/usr/share/haxe/std/haxe/io/Path.hx:231: lines 231-246
		$_g11 = 0;
		#/usr/share/haxe/std/haxe/io/Path.hx:231: lines 231-246
		$_g2 = strlen($tmp);
		#/usr/share/haxe/std/haxe/io/Path.hx:231: lines 231-246
		while ($_g11 < $_g2) {
			#/usr/share/haxe/std/haxe/io/Path.hx:231: lines 231-246
			$_g11 = $_g11 + 1;
			#/usr/share/haxe/std/haxe/io/Path.hx:231: characters 7-8
			$i = $_g11 - 1;
			#/usr/share/haxe/std/haxe/io/Path.hx:232: characters 11-41
			$_g21 = (strlen($tmp) === $i ? 0 : ord($tmp[$i]));
			#/usr/share/haxe/std/haxe/io/Path.hx:232: characters 11-41
			switch ($_g21) {
				case 47:
					#/usr/share/haxe/std/haxe/io/Path.hx:236: lines 236-244
					if (!$colon) {
						#/usr/share/haxe/std/haxe/io/Path.hx:237: characters 5-19
						$slashes = true;
					} else {
						#/usr/share/haxe/std/haxe/io/Path.hx:238: characters 9-10
						$i1 = $_g21;
						#/usr/share/haxe/std/haxe/io/Path.hx:239: characters 5-18
						$colon = false;
						#/usr/share/haxe/std/haxe/io/Path.hx:240: lines 240-243
						if ($slashes) {
							#/usr/share/haxe/std/haxe/io/Path.hx:241: characters 6-18
							$acc->add("/");
							#/usr/share/haxe/std/haxe/io/Path.hx:242: characters 6-21
							$slashes = false;
						}
						#/usr/share/haxe/std/haxe/io/Path.hx:244: characters 5-8
						$acc1 = $acc;
						#/usr/share/haxe/std/haxe/io/Path.hx:244: characters 5-19
						$acc1->b = ($acc1->b??'null') . (HxString::fromCharCode($i1)??'null');

					}
					break;
				case 58:
					#/usr/share/haxe/std/haxe/io/Path.hx:234: characters 5-17
					$acc->add(":");
					#/usr/share/haxe/std/haxe/io/Path.hx:235: characters 5-17
					$colon = true;
					break;
				default:
					#/usr/share/haxe/std/haxe/io/Path.hx:238: characters 9-10
					$i2 = $_g21;
					#/usr/share/haxe/std/haxe/io/Path.hx:239: characters 5-18
					$colon = false;
					#/usr/share/haxe/std/haxe/io/Path.hx:240: lines 240-243
					if ($slashes) {
						#/usr/share/haxe/std/haxe/io/Path.hx:241: characters 6-18
						$acc->add("/");
						#/usr/share/haxe/std/haxe/io/Path.hx:242: characters 6-21
						$slashes = false;
					}
					#/usr/share/haxe/std/haxe/io/Path.hx:244: characters 5-8
					$acc2 = $acc;
					#/usr/share/haxe/std/haxe/io/Path.hx:244: characters 5-19
					$acc2->b = ($acc2->b??'null') . (HxString::fromCharCode($i2)??'null');

					break;
			}

		}

		#/usr/share/haxe/std/haxe/io/Path.hx:247: characters 2-23
		return $acc->b;
	}


	/**
	 * Creates a new Path instance by parsing `path`.
	 * Path information can be retrieved by accessing the dir, file and ext
	 * properties.
	 * 
	 * @param string $path
	 * 
	 * @return void
	 */
	public function __construct ($path) {
		#/usr/share/haxe/std/haxe/io/Path.hx:77: lines 77-82
		switch ($path) {
			case ".":
			case "..":
				#/usr/share/haxe/std/haxe/io/Path.hx:79: characters 4-14
				$this->dir = $path;
				#/usr/share/haxe/std/haxe/io/Path.hx:80: characters 4-13
				$this->file = "";
				#/usr/share/haxe/std/haxe/io/Path.hx:81: characters 4-10
				return;
				break;
		}
		#/usr/share/haxe/std/haxe/io/Path.hx:83: characters 2-33
		$c1 = HxString::lastIndexOf($path, "/");
		#/usr/share/haxe/std/haxe/io/Path.hx:84: characters 2-34
		$c2 = HxString::lastIndexOf($path, "\\");
		#/usr/share/haxe/std/haxe/io/Path.hx:85: lines 85-93
		if ($c1 < $c2) {
			#/usr/share/haxe/std/haxe/io/Path.hx:86: characters 3-26
			$this->dir = HxString::substr($path, 0, $c2);
			#/usr/share/haxe/std/haxe/io/Path.hx:87: characters 3-27
			$path = HxString::substr($path, $c2 + 1);
			#/usr/share/haxe/std/haxe/io/Path.hx:88: characters 3-19
			$this->backslash = true;
		} else if ($c2 < $c1) {
			#/usr/share/haxe/std/haxe/io/Path.hx:90: characters 3-26
			$this->dir = HxString::substr($path, 0, $c1);
			#/usr/share/haxe/std/haxe/io/Path.hx:91: characters 3-27
			$path = HxString::substr($path, $c1 + 1);
		} else {
			#/usr/share/haxe/std/haxe/io/Path.hx:93: characters 3-13
			$this->dir = null;
		}
		#/usr/share/haxe/std/haxe/io/Path.hx:94: characters 2-33
		$cp = HxString::lastIndexOf($path, ".");
		#/usr/share/haxe/std/haxe/io/Path.hx:95: lines 95-101
		if ($cp !== -1) {
			#/usr/share/haxe/std/haxe/io/Path.hx:96: characters 3-26
			$this->ext = HxString::substr($path, $cp + 1);
			#/usr/share/haxe/std/haxe/io/Path.hx:97: characters 3-27
			$this->file = HxString::substr($path, 0, $cp);
		} else {
			#/usr/share/haxe/std/haxe/io/Path.hx:99: characters 3-13
			$this->ext = null;
			#/usr/share/haxe/std/haxe/io/Path.hx:100: characters 3-14
			$this->file = $path;
		}
	}
}


Boot::registerClass(Path::class, 'haxe.io.Path');
