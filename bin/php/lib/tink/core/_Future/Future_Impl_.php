<?php
/**
 * Generated by Haxe 3.4.7
 */

namespace tink\core\_Future;

use \php\_Boot\HxClosure;
use \tink\core\FutureTrigger;
use \tink\core\OutcomeTools;
use \tink\core\Outcome;
use \tink\core\_Outcome\OutcomeMapper_Impl_;
use \php\Boot;
use \tink\core\MPair;
use \tink\core\_Callback\Callback_Impl_;
use \tink\core\Noise;
use \haxe\ds\Either;
use \tink\core\_Lazy\LazyObject;
use \tink\core\_Lazy\LazyConst;
use \haxe\Timer;

final class Future_Impl_ {
	/**
	 * @var FutureObject
	 */
	static public $NEVER;
	/**
	 * @var FutureObject
	 */
	static public $NOISE;
	/**
	 * @var FutureObject
	 */
	static public $NULL;


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _flatMap ($f, $map) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:182: characters 11-25
		$ret = $f->flatMap($map);
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:182: characters 11-25
		return $ret->gather();
	}


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _map ($f, $map) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:185: characters 11-21
		$ret = $f->map($map);
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:185: characters 11-21
		return $ret->gather();
	}


	/**
	 * @param \Closure $f
	 * 
	 * @return FutureObject
	 */
	static public function _new ($f) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:17: character 16
		$this1 = new SimpleFuture($f);
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:17: character 16
		return $this1;
	}


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _tryFailingFlatMap ($f, $map) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:164: lines 164-167
		$ret = $f->flatMap(function ($o)  use (&$map) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:164: lines 164-167
			switch (Boot::dynamicField($o, 'index')) {
				case 0:
					#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:165: characters 19-20
					$d = $o->params[0];
					#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:165: characters 23-29
					return $map($d);
					break;
				case 1:
					#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:166: characters 19-20
					$f1 = $o->params[0];
					#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:166: characters 23-46
					return new SyncFuture(new LazyConst(Outcome::Failure($f1)));
					break;
			}
		});
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:164: lines 164-167
		return $ret->gather();
	}


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _tryFailingMap ($f, $map) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:176: characters 11-52
		$ret = $f->map(function ($o)  use (&$map) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:176: characters 30-51
			return OutcomeTools::flatMap($o, OutcomeMapper_Impl_::withSameError($map));
		});
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:176: characters 11-52
		return $ret->gather();
	}


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _tryFlatMap ($f, $map) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:170: lines 170-173
		$ret = $f->flatMap(function ($o)  use (&$map) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:170: lines 170-173
			switch (Boot::dynamicField($o, 'index')) {
				case 0:
					#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:171: characters 19-20
					$d = $o->params[0];
					#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:171: characters 23-42
					$ret1 = $map($d)->map(new HxClosure(Outcome::class, 'Success'));
					#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:171: characters 23-42
					return $ret1->gather();
					break;
				case 1:
					#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:172: characters 19-20
					$f1 = $o->params[0];
					#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:172: characters 23-46
					return new SyncFuture(new LazyConst(Outcome::Failure($f1)));
					break;
			}
		});
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:170: lines 170-173
		return $ret->gather();
	}


	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	static public function _tryMap ($f, $map) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:179: characters 11-48
		$ret = $f->map(function ($o)  use (&$map) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:179: characters 30-47
			return OutcomeTools::map($o, $map);
		});
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:179: characters 11-48
		return $ret->gather();
	}


	/**
	 *  Uses `Pair` to merge two futures
	 * 
	 * @param FutureObject $a
	 * @param FutureObject $b
	 * 
	 * @return FutureObject
	 */
	static public function and ($a, $b) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:161: characters 4-60
		return Future_Impl_::merge($a, $b, function ($a1, $b1) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:161: characters 45-59
			$this1 = new MPair($a1, $b1);
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:161: characters 45-59
			return $this1;
		});
	}


	/**
	 *  Casts a Surprise into a Promise
	 * 
	 * @param FutureObject $s
	 * 
	 * @return FutureObject
	 */
	static public function asPromise ($s) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:93: characters 4-12
		return $s;
	}


	/**
	 *  Creates an async future
	 *  Example: `var i = Future.async(function(cb) cb(1)); // Future<Int>`
	 * 
	 * @param \Closure $f
	 * @param bool $lazy
	 * 
	 * @return FutureObject
	 */
	static public function async ($f, $lazy = false) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:136: lines 136-143
		if ($lazy === null) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:136: lines 136-143
			$lazy = false;
		}
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:136: lines 136-143
		if ($lazy) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:137: characters 6-31
			return new LazyTrigger($f);
		} else {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:139: characters 6-25
			$op = new FutureTrigger();
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:140: characters 6-40
			$wrapped = $f;
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:141: characters 6-32
			Callback_Impl_::invoke($wrapped, new HxClosure($op, 'trigger'));
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:142: characters 6-15
			return $op;
		}
	}


	/**
	 * @param int $ms
	 * @param LazyObject $value
	 * 
	 * @return FutureObject
	 */
	static public function delay ($ms, $value) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:194: characters 4-86
		return Future_Impl_::async(function ($cb)  use (&$ms, &$value) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:194: characters 37-85
			Timer::delay(function ()  use (&$cb, &$value) {
				#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:194: characters 65-80
				$cb($value->get());
			}, $ms);
		});
	}


	/**
	 *  Same as `first`, but use `Either` to handle the two different types
	 * 
	 * @param FutureObject $a
	 * @param FutureObject $b
	 * 
	 * @return FutureObject
	 */
	static public function either ($a, $b) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:155: characters 11-36
		$ret = $a->map(new HxClosure(Either::class, 'Left'));
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:155: characters 43-69
		$ret1 = $b->map(new HxClosure(Either::class, 'Right'));
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:155: characters 4-70
		return Future_Impl_::first($ret, $ret1);
	}


	/**
	 *  Creates a future that contains the first result from `this` or `other`
	 * 
	 * @param FutureObject $this
	 * @param FutureObject $other
	 * 
	 * @return FutureObject
	 */
	static public function first ($this1, $other) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:24: characters 4-31
		$ret = new FutureTrigger();
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:25: characters 4-38
		$l1 = $this1->handle(new HxClosure($ret, 'trigger'));
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:26: characters 4-39
		$l2 = $other->handle(new HxClosure($ret, 'trigger'));
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:27: characters 4-29
		$ret1 = $ret;
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:28: lines 28-29
		if ($l1 !== null) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:29: characters 17-19
			$this2 = $l1;
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:29: characters 6-20
			$ret1->handle(function ($_)  use (&$this2) {
				#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:29: characters 17-19
				$this2->cancel();
			});
		}
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:30: lines 30-31
		if ($l2 !== null) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:31: characters 17-19
			$this3 = $l2;
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:31: characters 6-20
			$ret1->handle(function ($_1)  use (&$this3) {
				#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:31: characters 17-19
				$this3->cancel();
			});
		}
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:32: characters 4-14
		return $ret1;
	}


	/**
	 *  Creates a new future by applying a transform function to the result.
	 *  Different from `map`, the transform function of `flatMap` returns a `Future`
	 * 
	 * @param FutureObject $this
	 * @param \Closure $next
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	static public function flatMap ($this1, $next, $gather = true) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:50: lines 50-55
		if ($gather === null) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:50: lines 50-55
			$gather = true;
		}
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:51: characters 4-33
		$ret = $this1->flatMap($next);
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:53: lines 53-54
		if ($gather) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:53: characters 18-30
			return $ret->gather();
		} else {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:54: characters 11-14
			return $ret;
		}
	}


	/**
	 *  Flattens `Future<Future<A>>` into `Future<A>`
	 * 
	 * @param FutureObject $f
	 * 
	 * @return FutureObject
	 */
	static public function flatten ($f) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:76: characters 4-30
		return new NestedFuture($f);
	}


	/**
	 * @param \Array_hx $futures
	 * 
	 * @return FutureObject
	 */
	static public function fromMany ($futures) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:117: characters 4-26
		return Future_Impl_::ofMany($futures);
	}


	/**
	 * @param LazyObject $l
	 * 
	 * @return FutureObject
	 */
	static public function lazy ($l) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:121: characters 4-28
		return new SyncFuture($l);
	}


	/**
	 *  Creates a new future by applying a transform function to the result.
	 *  Different from `flatMap`, the transform function of `map` returns a sync value
	 * 
	 * @param FutureObject $this
	 * @param \Closure $f
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	static public function map ($this1, $f, $gather = true) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:39: lines 39-44
		if ($gather === null) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:39: lines 39-44
			$gather = true;
		}
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:40: characters 4-26
		$ret = $this1->map($f);
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:42: lines 42-43
		if ($gather) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:42: characters 18-30
			return $ret->gather();
		} else {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:43: characters 11-14
			return $ret;
		}
	}


	/**
	 *  Merges two futures into one by applying the merger function on the two future values
	 * 
	 * @param FutureObject $this
	 * @param FutureObject $other
	 * @param \Closure $merger
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	static public function merge ($this1, $other, $merger, $gather = true) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:68: lines 68-70
		if ($gather === null) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:68: lines 68-70
			$gather = true;
		}
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:68: lines 68-70
		$ret = $this1->flatMap(function ($t)  use (&$other, &$merger) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:69: characters 13-65
			$ret1 = $other->map(function ($a)  use (&$t, &$merger) {
				#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:69: characters 38-57
				return $merger($t, $a);
			});
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:69: characters 13-65
			return $ret1;
		});
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:68: lines 68-70
		if ($gather) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:68: lines 68-70
			return $ret->gather();
		} else {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:68: lines 68-70
			return $ret;
		}
	}


	/**
	 *  Like `map` and `flatMap` but with a polymorphic transformer and return a `Promise`
	 *  @see `Next`
	 * 
	 * @param FutureObject $this
	 * @param \Closure $n
	 * 
	 * @return FutureObject
	 */
	static public function next ($this1, $n) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:62: characters 4-49
		return $this1->flatMap(function ($v)  use (&$n) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:62: characters 37-48
			return $n($v);
		});
	}


	/**
	 * @param mixed $v
	 * 
	 * @return FutureObject
	 */
	static public function ofAny ($v) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:87: characters 4-25
		return new SyncFuture(new LazyConst($v));
	}


	/**
	 *  Merges multiple futures into Future<Array<A>>
	 * 
	 * @param \Array_hx $futures
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	static public function ofMany ($futures, $gather = true) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:98: lines 98-113
		if ($gather === null) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:98: lines 98-113
			$gather = true;
		}
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:99: characters 4-23
		$ret = new SyncFuture(new LazyConst(new \Array_hx()));
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:100: lines 100-109
		$_g = 0;
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:100: lines 100-109
		while ($_g < $futures->length) {
			unset($f);
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:100: characters 9-10
			$f = ($futures->arr[$_g] ?? null);
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:100: lines 100-109
			$_g = $_g + 1;
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:101: lines 101-109
			$ret1 = $ret->flatMap(function ($results)  use (&$f) {
				#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:103: lines 103-107
				$ret2 = $f->map(function ($result)  use (&$results) {
					#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:105: characters 14-45
					return $results->concat(\Array_hx::wrap([$result]));
				});
				#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:103: lines 103-107
				return $ret2;
			});
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:101: lines 101-109
			$ret = $ret1;
		}

		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:111: lines 111-112
		if ($gather) {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:111: characters 18-30
			return $ret->gather();
		} else {
			#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:112: characters 11-14
			return $ret;
		}
	}


	/**
	 *  Same as `first`
	 * 
	 * @param FutureObject $a
	 * @param FutureObject $b
	 * 
	 * @return FutureObject
	 */
	static public function or ($a, $b) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:149: characters 4-21
		return Future_Impl_::first($a, $b);
	}


	/**
	 *  Creates a sync future.
	 *  Example: `var i = Future.sync(1); // Future<Int>`
	 * 
	 * @param mixed $v
	 * 
	 * @return FutureObject
	 */
	static public function sync ($v) {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:128: characters 4-28
		return new SyncFuture(new LazyConst($v));
	}


	/**
	 *  Creates a new `FutureTrigger`
	 * 
	 * @return FutureTrigger
	 */
	static public function trigger () {
		#/home/vagrant/haxelib/tink_core/1,23,0/src/tink/core/Future.hx:191: characters 4-30
		return new FutureTrigger();
	}


	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


self::$NULL = new SyncFuture(new LazyConst(null));
self::$NOISE = new SyncFuture(new LazyConst(Noise::Noise()));
self::$NEVER = NeverFuture::$inst;
	}
}


Boot::registerClass(Future_Impl_::class, 'tink.core._Future.Future_Impl_');
Future_Impl_::__hx__init();
